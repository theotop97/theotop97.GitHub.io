<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://theotop97.github.io</id>
    <title>Theo&apos;s Blogs</title>
    <updated>2021-07-21T17:49:21.801Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://theotop97.github.io"/>
    <link rel="self" href="https://theotop97.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://theotop97.github.io/images/avatar.png</logo>
    <icon>https://theotop97.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Theo&apos;s Blogs</rights>
    <entry>
        <title type="html"><![CDATA[adb命令大全]]></title>
        <id>https://theotop97.github.io/post/adb-all-command/</id>
        <link href="https://theotop97.github.io/post/adb-all-command/">
        </link>
        <updated>2021-07-21T17:39:01.000Z</updated>
        <content type="html"><![CDATA[<p>ADB，即 <a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a>，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。</p>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a>
<ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95">命令语法</a></li>
<li><a href="#%E4%B8%BA%E5%91%BD%E4%BB%A4%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E8%AE%BE%E5%A4%87">为命令指定目标设备</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2">启动/停止</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B-adb-%E7%89%88%E6%9C%AC">查看 adb 版本</a></li>
<li><a href="#%E4%BB%A5-root-%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C-adbd">以 root 权限运行 adbd</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">指定 adb server 的网络端口</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">设备连接管理</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%B7%B2%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F%E5%99%A8">查询已连接设备/模拟器</a></li>
<li><a href="#usb-%E8%BF%9E%E6%8E%A5">USB 连接</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5android11-%E5%8F%8A%E4%BB%A5%E4%B8%8A">无线连接（Android11 及以上）</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（需要借助 USB 线）</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%97%A0%E9%9C%80%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（无需借助 USB 线）</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86">应用管理</a>
<ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%88%97%E8%A1%A8">查看应用列表</a>
<ul>
<li><a href="#%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8">所有应用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8">系统应用</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8">第三方应用</a></li>
<li><a href="#%E5%8C%85%E5%90%8D%E5%8C%85%E5%90%AB%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8">包名包含某字符串的应用</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85-apk">安装 APK</a></li>
<li><a href="#%E5%8D%B8%E8%BD%BD%E5%BA%94%E7%94%A8">卸载应用</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BC%93%E5%AD%98">清除应用数据与缓存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%89%8D%E5%8F%B0-activity">查看前台 Activity</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-services">查看正在运行的 Services</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">查看应用详细信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">查看应用安装路径</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BA%92">与应用交互</a>
<ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8-%E8%B0%83%E8%B5%B7-activity">启动应用/ 调起 Activity</a></li>
<li><a href="#%E8%B0%83%E8%B5%B7-service">调起 Service</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2-service">停止 Service</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD">发送广播</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8">强制停止应用</a></li>
<li><a href="#%E6%94%B6%E7%B4%A7%E5%86%85%E5%AD%98">收紧内存</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a>
<ul>
<li><a href="#%E5%A4%8D%E5%88%B6%E8%AE%BE%E5%A4%87%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E7%94%B5%E8%84%91">复制设备里的文件到电脑</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%94%B5%E8%84%91%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E8%AE%BE%E5%A4%87">复制电脑里的文件到设备</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5">模拟按键/输入</a>
<ul>
<li><a href="#%E7%94%B5%E6%BA%90%E9%94%AE">电源键</a></li>
<li><a href="#%E8%8F%9C%E5%8D%95%E9%94%AE">菜单键</a></li>
<li><a href="#home-%E9%94%AE">HOME 键</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E9%94%AE">返回键</a></li>
<li><a href="#%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6">音量控制</a></li>
<li><a href="#%E5%AA%92%E4%BD%93%E6%8E%A7%E5%88%B6">媒体控制</a></li>
<li><a href="#%E7%82%B9%E4%BA%AE%E7%86%84%E7%81%AD%E5%B1%8F%E5%B9%95">点亮/熄灭屏幕</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81">滑动解锁</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC">输入文本</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97">查看日志</a>
<ul>
<li><a href="#android-%E6%97%A5%E5%BF%97">Android 日志</a>
<ul>
<li><a href="#%E6%8C%89%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按级别过滤日志</a></li>
<li><a href="#%E6%8C%89-tag-%E5%92%8C%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按 tag 和级别过滤日志</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">日志格式</a></li>
<li><a href="#%E6%B8%85%E7%A9%BA%E6%97%A5%E5%BF%97">清空日志</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97">内核日志</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF">查看设备信息</a>
<ul>
<li><a href="#%E5%9E%8B%E5%8F%B7">型号</a></li>
<li><a href="#%E7%94%B5%E6%B1%A0%E7%8A%B6%E5%86%B5">电池状况</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87">屏幕分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E6%95%B0">显示屏参数</a></li>
<li><a href="#android_id">android_id</a></li>
<li><a href="#imei">IMEI</a></li>
<li><a href="#android-%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC">Android 系统版本</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="#mac-%E5%9C%B0%E5%9D%80">Mac 地址</a></li>
<li><a href="#cpu-%E4%BF%A1%E6%81%AF">CPU 信息</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF">内存信息</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7">更多硬件与系统属性</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AE%BE%E7%BD%AE">修改设置</a>
<ul>
<li><a href="#%E5%88%86%E8%BE%A8%E7%8E%87">分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6-1">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%8C%BA%E5%9F%9F">显示区域</a></li>
<li><a href="#%E5%85%B3%E9%97%AD-usb-%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F">关闭 USB 调试模式</a></li>
<li><a href="#%E5%85%81%E8%AE%B8%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E9%9D%9E-sdk-api">允许/禁止访问非 SDK API</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F">状态栏和导航栏的显示隐藏</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD">实用功能</a>
<ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">屏幕截图</a></li>
<li><a href="#%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95">录制屏幕</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E6%8C%82%E8%BD%BD-system-%E5%88%86%E5%8C%BA%E4%B8%BA%E5%8F%AF%E5%86%99">重新挂载 system 分区为可写</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84-wifi-%E5%AF%86%E7%A0%81">查看连接过的 WiFi 密码</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4">设置系统日期和时间</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E6%89%8B%E6%9C%BA">重启手机</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E5%B7%B2-root">检测设备是否已 root</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-monkey-%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">使用 Monkey 进行压力测试</a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD-wifi">开启/关闭 WiFi</a></li>
</ul>
</li>
<li><a href="#%E5%88%B7%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">刷机相关命令</a>
<ul>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-recovery-%E6%A8%A1%E5%BC%8F">重启到 Recovery 模式</a></li>
<li><a href="#%E4%BB%8E-recovery-%E9%87%8D%E5%90%AF%E5%88%B0-android">从 Recovery 重启到 Android</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-fastboot-%E6%A8%A1%E5%BC%8F">重启到 Fastboot 模式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-sideload-%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">通过 sideload 更新系统</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">安全相关命令</a>
<ul>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-selinux">启用/禁用 SELinux</a></li>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-dm_verity">启用/禁用 dm_verity</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A-adb-shell-%E5%91%BD%E4%BB%A4">更多 adb shell 命令</a>
<ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5">查看实时资源占用情况</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-uid">查看进程 UID</a></li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a>
<ul>
<li><a href="#%E5%90%AF%E5%8A%A8-adb-server-%E5%A4%B1%E8%B4%A5">启动 adb server 失败</a></li>
<li><a href="#comandroidddmlibadbcommandrejectedexception">com.android.ddmlib.AdbCommandRejectedException</a></li>
</ul>
</li>
<li><a href="#adb-%E7%9A%84%E9%9D%9E%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0">adb 的非官方实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">相关命令</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<!-- vim-markdown-toc -->
<h2 id="基本用法">基本用法</h2>
<h3 id="命令语法">命令语法</h3>
<p>adb 命令的基本语法如下：</p>
<pre><code class="language-sh">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;
</code></pre>
<p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="为命令指定目标设备">为命令指定目标设备</h3>
<p>如果有多个设备/模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serialNumber&gt;</code></td>
<td>指定相应 serialNumber 号的设备/模拟器为命令目标</td>
</tr>
</tbody>
</table>
<p>在多个设备/模拟器连接的情况下较常用的是 <code>-s &lt;serialNumber&gt;</code> 参数，serialNumber 可以通过 <code>adb devices</code> 命令获取。如：</p>
<pre><code class="language-sh">$ adb devices

List of devices attached
cf264b8f	device
emulator-5554	device
10.129.164.6:5555	device
</code></pre>
<p>输出里的 <code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 即为 serialNumber。</p>
<p>比如这时想指定 <code>cf264b8f</code> 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<pre><code class="language-sh">adb -s cf264b8f shell wm size
</code></pre>
<p>又如想给 <code>10.129.164.6:5555</code> 这个设备安装应用（<em>这种形式的 serialNumber 格式为 <code>&lt;IP&gt;:&lt;Port&gt;</code>，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器</em>）：</p>
<pre><code class="language-sh">adb -s 10.129.164.6:5555 install test.apk
</code></pre>
<p><strong>遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</strong></p>
<h3 id="启动停止">启动/停止</h3>
<p>启动 adb server 命令：</p>
<pre><code class="language-sh">adb start-server
</code></pre>
<p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<pre><code class="language-sh">adb kill-server
</code></pre>
<h3 id="查看-adb-版本">查看 adb 版本</h3>
<p>命令：</p>
<pre><code class="language-sh">adb version
</code></pre>
<p>示例输出：</p>
<pre><code class="language-sh">Android Debug Bridge version 1.0.36
Revision 8f855a3d9b35-android
</code></pre>
<h3 id="以-root-权限运行-adbd">以 root 权限运行 adbd</h3>
<p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 <code>adb xxx</code> 执行。这时可以 <code>adb shell</code> 然后 <code>su</code> 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<pre><code class="language-sh">adb root
</code></pre>
<p>正常输出：</p>
<pre><code class="language-sh">restarting adbd as root
</code></pre>
<p>现在再运行 <code>adb shell</code>，看看命令行提示符是不是变成 <code>#</code> 了？</p>
<p>有些手机 root 后也无法通过 <code>adb root</code> 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 <code>adbd cannot run as root in production builds</code>，此时可以先安装 adbd Insecure，然后 <code>adb root</code> 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <code>adb unroot</code> 命令。</p>
<h3 id="指定-adb-server-的网络端口">指定 adb server 的网络端口</h3>
<p>命令：</p>
<pre><code class="language-sh">adb -P &lt;port&gt; start-server
</code></pre>
<p>默认端口为 5037。</p>
<h2 id="设备连接管理">设备连接管理</h2>
<h3 id="查询已连接设备模拟器">查询已连接设备/模拟器</h3>
<p>命令：</p>
<pre><code class="language-sh">adb devices
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">List of devices attached
cf264b8f	device
emulator-5554	device
10.129.164.6:5555	device
</code></pre>
<p>输出格式为 <code>[serialNumber] [state]</code>，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li>
<p><code>offline</code> —— 表示设备未连接成功或无响应。</p>
</li>
<li>
<p><code>device</code> —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</p>
</li>
<li>
<p><code>no device</code> —— 没有设备/模拟器连接。</p>
</li>
</ul>
<p>以上输出显示当前已经连接了三台设备/模拟器，<code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 分别是它们的 SN。从 <code>emulator-5554</code> 这个名字可以看出它是一个 Android 模拟器，而 <code>10.129.164.6:5555</code> 这种形为 <code>&lt;IP&gt;:&lt;Port&gt;</code> 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<ol>
<li>
<p>没有设备/模拟器连接成功。</p>
<pre><code class="language-sh">List of devices attached
</code></pre>
</li>
<li>
<p>设备/模拟器未连接到 adb 或无响应。</p>
<pre><code class="language-sh">List of devices attached
cf264b8f	offline
</code></pre>
</li>
</ol>
<h3 id="usb-连接">USB 连接</h3>
<p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li>
<p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
</li>
<li>
<p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
</li>
<li>
<p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
</li>
<li>
<p>通过 USB 线连接好电脑和设备后确认状态。</p>
<pre><code class="language-sh">adb devices
</code></pre>
<p>如果能看到</p>
<pre><code class="language-sh">xxxxxx device
</code></pre>
<p>说明连接成功。</p>
</li>
</ol>
<h3 id="无线连接android11-及以上">无线连接（Android11 及以上）</h3>
<p>Android 11 及更高版本支持使用 Android 调试桥 (adb) 从工作站以无线方式部署和调试应用。例如，您可以将可调试应用部署到多台远程设备，而无需通过 USB 实际连接设备。这样就可以避免常见的 USB 连接问题，例如驱动程序安装方面的问题。</p>
<p><a href="https://developer.android.com/studio/command-line/adb?hl=zh_cn#connect-to-a-device-over-wi-fi-android-11+">官方文档</a></p>
<p>操作步骤：</p>
<ol>
<li>
<p>更新到最新版本的 <a href="https://developer.android.com/studio/releases/platform-tools?hl=zh_cn">SDK 平台工具</a>(至少30.0.0)。</p>
</li>
<li>
<p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li>
<p>在开发者选项中启用<strong>无线调试</strong>。</p>
</li>
<li>
<p>在询问要允许在此网络上进行无线调试吗？的对话框中，点击允许。</p>
</li>
<li>
<p>选择使用配对码配对设备，使用弹窗中的 IP 地址和端口号。</p>
</li>
</ol>
<pre><code class="language-sh">adb pair ipaddr:port
</code></pre>
<ol start="6">
<li>
<p>提示<code>Enter pairing code:</code>时输入弹窗中的配对码，成功后会显示<code>Successfully paired to ...</code>。</p>
</li>
<li>
<p>使用无线调试下的 <strong>IP 地址和端口</strong>。</p>
</li>
</ol>
<pre><code class="language-sh">adb connect ipaddr:port
</code></pre>
<ol start="8">
<li>
<p>确认连接状态。</p>
<pre><code class="language-sh">adb devices
</code></pre>
<p>如果能看到</p>
<pre><code class="language-sh">ipaddr:port device
</code></pre>
</li>
</ol>
<p>说明连接成功。</p>
<h3 id="无线连接需要借助-usb-线">无线连接（需要借助 USB 线）</h3>
<p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：</p>
<ol>
<li>
<p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li>
<p>将设备与电脑通过 USB 线连接。</p>
<p>应确保连接成功（可运行 <code>adb devices</code> 看是否能列出该设备）。</p>
</li>
<li>
<p>让设备在 5555 端口监听 TCP/IP 连接：</p>
<pre><code class="language-sh">adb tcpip 5555
</code></pre>
</li>
<li>
<p>断开 USB 连接。</p>
</li>
<li>
<p>找到设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1] 一节里的方法用 adb 命令来查看。</p>
</li>
<li>
<p>通过 IP 地址连接设备。</p>
<pre><code class="language-sh">adb connect &lt;device-ip-address&gt;
</code></pre>
<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
</li>
<li>
<p>确认连接状态。</p>
<pre><code class="language-sh">adb devices
</code></pre>
<p>如果能看到</p>
<pre><code class="language-sh">&lt;device-ip-address&gt;:5555 device
</code></pre>
<p>说明连接成功。</p>
</li>
</ol>
<p>如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；</p>
<p>如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<p><strong>断开无线连接</strong></p>
<p>命令：</p>
<pre><code class="language-sh">adb disconnect &lt;device-ip-address&gt;
</code></pre>
<h3 id="无线连接无需借助-usb-线">无线连接（无需借助 USB 线）</h3>
<p><strong>注：需要 root 权限。</strong></p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。</p>
<p>既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。</p>
<ol>
<li>
<p>在 Android 设备上安装一个终端模拟器。</p>
<p>已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：<a href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></p>
</li>
<li>
<p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li>
<p>打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
<pre><code class="language-sh">su
setprop service.adb.tcp.port 5555
</code></pre>
</li>
<li>
<p>找到 Android 设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 [查看设备信息 - IP 地址][1] 一节里的方法用 adb 命令来查看。</p>
</li>
<li>
<p>在电脑上通过 adb 和 IP 地址连接 Android 设备。</p>
<pre><code class="language-sh">adb connect &lt;device-ip-address&gt;
</code></pre>
<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
<p>如果能看到 <code>connected to &lt;device-ip-address&gt;:5555</code> 这样的输出则表示连接成功。</p>
</li>
</ol>
<p><em>节注一：</em></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<pre><code class="language-sh">restart adbd
</code></pre>
<p>如果 restart 无效，尝试以下命令：</p>
<pre><code class="language-sh">stop adbd
start adbd
</code></pre>
<h2 id="应用管理">应用管理</h2>
<h3 id="查看应用列表">查看应用列表</h3>
<p>查看应用列表的基本命令格式是</p>
<pre><code class="language-sh">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]
</code></pre>
<p>即在 <code>adb shell pm list packages</code> 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody>
</table>
<h4 id="所有应用">所有应用</h4>
<p>命令：</p>
<pre><code class="language-sh">adb shell pm list packages
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">package:com.android.smoketest
package:com.example.android.livecubes
package:com.android.providers.telephony
package:com.google.android.googlequicksearchbox
package:com.android.providers.calendar
package:com.android.providers.media
package:com.android.protips
package:com.android.documentsui
package:com.android.gallery
package:com.android.externalstorage
...
// other packages here
...
</code></pre>
<h4 id="系统应用">系统应用</h4>
<p>命令：</p>
<pre><code class="language-sh">adb shell pm list packages -s
</code></pre>
<h4 id="第三方应用">第三方应用</h4>
<p>命令：</p>
<pre><code class="language-sh">adb shell pm list packages -3
</code></pre>
<h4 id="包名包含某字符串的应用">包名包含某字符串的应用</h4>
<p>比如要查看包名包含字符串 <code>mazhuang</code> 的应用列表，命令：</p>
<pre><code class="language-sh">adb shell pm list packages mazhuang
</code></pre>
<p>当然也可以使用 grep 来过滤：</p>
<pre><code class="language-sh">adb shell pm list packages | grep mazhuang
</code></pre>
<h3 id="安装-apk">安装 APK</h3>
<p>命令格式：</p>
<pre><code class="language-sh">adb install [-lrtsdg] &lt;path_to_apk&gt;
</code></pre>
<p>参数：</p>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody>
</table>
<p>运行命令后如果见到类似如下输出（状态为 <code>Success</code>）代表安装成功：</p>
<pre><code class="language-sh">[100%] /data/local/tmp/1.apk
	pkg: /data/local/tmp/1.apk
Success
</code></pre>
<p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<pre><code class="language-sh">12040 KB/s (22205609 bytes in 1.801s)
        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk
Success
</code></pre>
<p>而如果状态为 <code>Failure</code> 则表示安装失败，比如：</p>
<pre><code class="language-sh">[100%] /data/local/tmp/map-20160831.apk
        pkg: /data/local/tmp/map-20160831.apk
Failure [INSTALL_FAILED_ALREADY_EXISTS]
</code></pre>
<p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td>在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied ... sdcard ...</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody>
</table>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java">PackageManager.java</a></p>
<p><em><code>adb install</code> 内部原理简介</em></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li>
<p>push apk 文件到 /data/local/tmp。</p>
</li>
<li>
<p>调用 pm install 安装。</p>
</li>
<li>
<p>删除 /data/local/tmp 下的对应 apk 文件。</p>
</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用">卸载应用</h3>
<p>命令：</p>
<pre><code class="language-sh">adb uninstall [-k] &lt;packagename&gt;
</code></pre>
<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<pre><code class="language-sh">adb uninstall com.qihoo360.mobilesafe
</code></pre>
<p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存">清除应用数据与缓存</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell pm clear &lt;packagename&gt;
</code></pre>
<p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<pre><code class="language-sh">adb shell pm clear com.qihoo360.mobilesafe
</code></pre>
<p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-activity">查看前台 Activity</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell dumpsys activity activities | grep mResumedActivity
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">mResumedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42}
</code></pre>
<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<p><em>在 Windows 下以上命令可能不可用，可以尝试 <code>adb shell dumpsys activity activities | findstr mResumedActivity</code> 或 <code>adb shell &quot;dumpsys activity activities | grep mResumedActivity&quot;</code>。</em></p>
<h3 id="查看正在运行的-services">查看正在运行的 Services</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell dumpsys activity services [&lt;packagename&gt;]
</code></pre>
<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.mazhuang</code>，那么包名 <code>org.mazhuang.demo1</code>、<code>org.mazhuang.demo2</code> 和 <code>org.mazhuang123</code> 等相关的 Services 都会列出来。</p>
<h3 id="查看应用详细信息">查看应用详细信息</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell dumpsys package &lt;packagename&gt;
</code></pre>
<p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<p><code>&lt;packagename&gt;</code> 表示应用包名。</p>
<p>输出示例：</p>
<pre><code class="language-sh">Activity Resolver Table:
  Non-Data Actions:
      android.intent.action.MAIN:
        5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc
          Action: &quot;android.intent.action.MAIN&quot;
          Category: &quot;android.intent.category.LAUNCHER&quot;
          AutoVerify=false

Registered ContentProviders:
  org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider:
    Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}

ContentProvider Authorities:
  [org.mazhuang.guanggoo.fileProvider]:
    Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}
      applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}

Key Set Manager:
  [org.mazhuang.guanggoo]
      Signing KeySets: 501

Packages:
  Package [org.mazhuang.guanggoo] (c1d7f):
    userId=10394
    pkg=Package{55f714c org.mazhuang.guanggoo}
    codePath=/data/app/org.mazhuang.guanggoo-2
    resourcePath=/data/app/org.mazhuang.guanggoo-2
    legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib
    primaryCpuAbi=null
    secondaryCpuAbi=null
    versionCode=74 minSdk=15 targetSdk=25
    versionName=1.1.74
    splits=[base]
    apkSigningVersion=2
    applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}
    flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]
    privateFlags=[ RESIZEABLE_ACTIVITIES ]
    dataDir=/data/user/0/org.mazhuang.guanggoo
    supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]
    timeStamp=2017-10-22 23:50:53
    firstInstallTime=2017-10-22 23:50:25
    lastUpdateTime=2017-10-22 23:50:55
    installerPackageName=com.miui.packageinstaller
    signatures=PackageSignatures{af09595 [53c7caa2]}
    installPermissionsFixed=true installStatus=1
    pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]
    requested permissions:
      android.permission.READ_PHONE_STATE
      android.permission.INTERNET
      android.permission.ACCESS_NETWORK_STATE
      android.permission.ACCESS_WIFI_STATE
      android.permission.READ_LOGS
      android.permission.WRITE_EXTERNAL_STORAGE
      android.permission.READ_EXTERNAL_STORAGE
    install permissions:
      android.permission.INTERNET: granted=true
      android.permission.ACCESS_NETWORK_STATE: granted=true
      android.permission.ACCESS_WIFI_STATE: granted=true
    User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0
      gids=[3003]
      runtime permissions:
        android.permission.READ_EXTERNAL_STORAGE: granted=true
        android.permission.READ_PHONE_STATE: granted=true
        android.permission.WRITE_EXTERNAL_STORAGE: granted=true
    User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0
      gids=[3003]
      runtime permissions:


Dexopt state:
  [org.mazhuang.guanggoo]
    Instruction Set: arm64
      path: /data/app/org.mazhuang.guanggoo-2/base.apk
      status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa
      te]
</code></pre>
<h3 id="查看应用安装路径">查看应用安装路径</h3>
<p>命令:</p>
<pre><code>adb shell pm path &lt;PACKAGE&gt;
</code></pre>
<p>输出应用安装路径</p>
<p>输出示例:</p>
<pre><code>adb shell pm path ecarx.weather

package:/data/app/ecarx.weather-1.apk
</code></pre>
<h2 id="与应用交互">与应用交互</h2>
<p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody>
</table>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody>
</table>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td><code>-e|--es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;</code></td>
<td>string 值</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody>
</table>
<h3 id="启动应用-调起-activity">启动应用/ 调起 Activity</h3>
<blockquote>
<p>指定Activity名称启动</p>
</blockquote>
<p>命令格式：</p>
<pre><code class="language-sh">adb shell am start [options] &lt;INTENT&gt;
</code></pre>
<p>例如：</p>
<pre><code class="language-sh">adb shell am start -n com.tencent.mm/.ui.LauncherUI
</code></pre>
<p>表示调起微信主界面。</p>
<pre><code class="language-sh">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;toast&quot; &quot;hello, world&quot;
</code></pre>
<p>表示调起 <code>org.mazhuang.boottimemeasure/.MainActivity</code> 并传给它 string 数据键值对 <code>toast - hello, world</code>。</p>
<blockquote>
<p>不指定Activity名称启动（启动主Activity）</p>
</blockquote>
<p>命令格式：</p>
<pre><code class="language-sh">adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1
</code></pre>
<p>例如：</p>
<pre><code class="language-sh">adb shell monkey -p com.tencent.mm -c android.intent.category.LAUNCHER 1
</code></pre>
<p>表示调起微信主界面。</p>
<h3 id="调起-service">调起 Service</h3>
<p>命令格式：</p>
<pre><code class="language-sh">adb shell am startservice [options] &lt;INTENT&gt;
</code></pre>
<p>例如：</p>
<pre><code class="language-sh">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService
</code></pre>
<p>表示调起微信的某 Service。</p>
<p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<pre><code class="language-sh">adb shell am startservice -n com.android.systemui/.SystemUIService
</code></pre>
<h3 id="停止-service">停止 Service</h3>
<p>命令格式：</p>
<pre><code class="language-sh">adb shell am stopservice [options] &lt;INTENT&gt;
</code></pre>
<h3 id="发送广播">发送广播</h3>
<p>命令格式：</p>
<pre><code class="language-sh">adb shell am broadcast [options] &lt;INTENT&gt;
</code></pre>
<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<pre><code class="language-sh">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED
</code></pre>
<p>又例如，只向 <code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<pre><code class="language-sh">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver
</code></pre>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody>
</table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用">强制停止应用</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell am force-stop &lt;packagename&gt;
</code></pre>
<p>命令示例：</p>
<pre><code class="language-sh">adb shell am force-stop com.qihoo360.mobilesafe
</code></pre>
<p>表示停止 360 安全卫士的一切进程与服务。</p>
<h3 id="收紧内存">收紧内存</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell am send-trim-memory  &lt;pid&gt; &lt;level&gt;
</code></pre>
<p>pid: 进程 ID<br>
level:<br>
HIDDEN、RUNNING_MODERATE、BACKGROUND、<br>
RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</p>
<p>命令示例：</p>
<pre><code class="language-sh">adb shell am send-trim-memory 12345 RUNNING_LOW
</code></pre>
<p>表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。</p>
<h2 id="文件管理">文件管理</h2>
<h3 id="复制设备里的文件到电脑">复制设备里的文件到电脑</h3>
<p>命令：</p>
<pre><code class="language-sh">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]
</code></pre>
<p>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<pre><code class="language-sh">adb pull /sdcard/sr.mp4 ~/tmp/
</code></pre>
<p>*小技巧：*设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 <code>adb shell</code> 和 <code>su</code> 命令在 adb shell 里获取 root 权限后，先 <code>cp /path/on/device /sdcard/filename</code> 将文件复制到 sdcard，然后 <code>adb pull /sdcard/filename /path/on/pc</code>。</p>
<h3 id="复制电脑里的文件到设备">复制电脑里的文件到设备</h3>
<p>命令：</p>
<pre><code class="language-sh">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;
</code></pre>
<p>例：</p>
<pre><code class="language-sh">adb push ~/sr.mp4 /sdcard/
</code></pre>
<p>*小技巧：*设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 <code>adb push /path/on/pc /sdcard/filename</code>，然后 <code>adb shell</code> 和 <code>su</code> 在 adb shell 里获取 root 权限后，<code>cp /sdcard/filename /path/on/device</code>。</p>
<h2 id="模拟按键输入">模拟按键/输入</h2>
<p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p>
<p><code>input</code> 命令的完整 help 信息如下：</p>
<pre><code class="language-sh">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]

The sources are:
      mouse
      keyboard
      joystick
      touchnavigation
      touchpad
      trackball
      stylus
      dpad
      gesture
      touchscreen
      gamepad

The commands and default sources are:
      text &lt;string&gt; (Default: touchscreen)
      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)
      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)
      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)
      press (Default: trackball)
      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)
</code></pre>
<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody>
</table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h3 id="电源键">电源键</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell input keyevent 26
</code></pre>
<p>执行效果相当于按电源键。</p>
<h3 id="菜单键">菜单键</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell input keyevent 82
</code></pre>
<h3 id="home-键">HOME 键</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell input keyevent 3
</code></pre>
<h3 id="返回键">返回键</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell input keyevent 4
</code></pre>
<h3 id="音量控制">音量控制</h3>
<p>增加音量：</p>
<pre><code class="language-sh">adb shell input keyevent 24
</code></pre>
<p>降低音量：</p>
<pre><code class="language-sh">adb shell input keyevent 25
</code></pre>
<p>静音：</p>
<pre><code class="language-sh">adb shell input keyevent 164
</code></pre>
<h3 id="媒体控制">媒体控制</h3>
<p>播放/暂停：</p>
<pre><code class="language-sh">adb shell input keyevent 85
</code></pre>
<p>停止播放：</p>
<pre><code class="language-sh">adb shell input keyevent 86
</code></pre>
<p>播放下一首：</p>
<pre><code class="language-sh">adb shell input keyevent 87
</code></pre>
<p>播放上一首：</p>
<pre><code class="language-sh">adb shell input keyevent 88
</code></pre>
<p>恢复播放：</p>
<pre><code class="language-sh">adb shell input keyevent 126
</code></pre>
<p>暂停播放：</p>
<pre><code class="language-sh">adb shell input keyevent 127
</code></pre>
<h3 id="点亮熄灭屏幕">点亮/熄灭屏幕</h3>
<p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p>点亮屏幕：</p>
<pre><code class="language-sh">adb shell input keyevent 224
</code></pre>
<p>熄灭屏幕：</p>
<pre><code class="language-sh">adb shell input keyevent 223
</code></pre>
<h3 id="滑动解锁">滑动解锁</h3>
<p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<pre><code class="language-sh">adb shell input swipe 300 1000 300 500
</code></pre>
<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h3 id="输入文本">输入文本</h3>
<p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<pre><code class="language-sh">adb shell input text hello
</code></pre>
<p>现在 <code>hello</code> 出现在文本框了。</p>
<h2 id="查看日志">查看日志</h2>
<p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h3 id="android-日志">Android 日志</h3>
<p>命令格式：</p>
<pre><code class="language-sh">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...
</code></pre>
<p>常用用法列举如下：</p>
<h4 id="按级别过滤日志">按级别过滤日志</h4>
<p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<pre><code class="language-sh">adb logcat *:W
</code></pre>
<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h4 id="按-tag-和级别过滤日志">按 tag 和级别过滤日志</h4>
<p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<pre><code class="language-sh">adb logcat ActivityManager:I MyApp:D *:S
</code></pre>
<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h4 id="日志格式">日志格式</h4>
<p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li>
<p>brief</p>
<p>默认格式。格式为：</p>
<pre><code class="language-sh">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>
<p>process</p>
<p>格式为：</p>
<pre><code class="language-sh">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)
</code></pre>
</li>
<li>
<p>tag</p>
<p>格式为：</p>
<pre><code class="language-sh">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">D/HeadsetStateMachine: Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>
<p>raw</p>
<p>格式为：</p>
<pre><code class="language-sh">&lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>
<p>time</p>
<p>格式为：</p>
<pre><code class="language-sh">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>
<p>threadtime</p>
<p>格式为：</p>
<pre><code class="language-sh">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0
</code></pre>
</li>
<li>
<p>long</p>
<p>格式为：</p>
<pre><code class="language-sh">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]
&lt;message&gt;
</code></pre>
<p>示例：</p>
<pre><code class="language-sh">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ]
Disconnected process message: 10, size: 0
</code></pre>
</li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<pre><code class="language-sh">adb logcat -v long ActivityManager:I *:S
</code></pre>
<h4 id="清空日志">清空日志</h4>
<pre><code class="language-sh">adb logcat -c
</code></pre>
<h3 id="内核日志">内核日志</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell dmesg
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs
&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs
&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs
&lt;4&gt;[14201.755954] Restarting tasks ... done.
&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC
&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC
&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.
</code></pre>
<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h2 id="查看设备信息">查看设备信息</h2>
<h3 id="型号">型号</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell getprop ro.product.model
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">Nexus 5
</code></pre>
<h3 id="电池状况">电池状况</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell dumpsys battery
</code></pre>
<p>输入示例：</p>
<pre><code class="language-sh">Current Battery Service state:
  AC powered: false
  USB powered: true
  Wireless powered: false
  status: 2
  health: 2
  present: true
  level: 44
  scale: 100
  voltage: 3872
  temperature: 280
  technology: Li-poly
</code></pre>
<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率">屏幕分辨率</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell wm size
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">Physical size: 1080x1920
</code></pre>
<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre><code class="language-sh">Physical size: 1080x1920
Override size: 480x1024
</code></pre>
<p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h3 id="屏幕密度">屏幕密度</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell wm density
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">Physical density: 420
</code></pre>
<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<pre><code class="language-sh">Physical density: 480
Override density: 160
</code></pre>
<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数">显示屏参数</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell dumpsys window displays
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)
  Display: mDisplayId=0
    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731
    deferred=false layoutNeeded=false
</code></pre>
<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h3 id="android_id">android_id</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell settings get secure android_id
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">51b6be48bac8c569
</code></pre>
<h3 id="imei">IMEI</h3>
<p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<pre><code class="language-sh">adb shell dumpsys iphonesubinfo
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">Phone Subscriber Info:
  Phone Type = GSM
  Device ID = 860955027785041
</code></pre>
<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<pre><code class="language-sh">adb shell
su
service call iphonesubinfo 1
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">Result: Parcel(
  0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.'
  0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.'
  0x00000020: 00340030 00000031                   '0.4.1...        ')
</code></pre>
<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h3 id="android-系统版本">Android 系统版本</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell getprop ro.build.version.release
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">5.0.2
</code></pre>
<h3 id="ip-地址">IP 地址</h3>
<p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<pre><code class="language-sh">adb shell ifconfig | grep Mask
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">inet addr:10.130.245.230  Mask:255.255.255.252
inet addr:127.0.0.1  Mask:255.0.0.0
</code></pre>
<p>那么 <code>10.130.245.230</code> 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<pre><code class="language-sh">adb shell ifconfig wlan0
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]
</code></pre>
<p>或</p>
<pre><code class="language-sh">wlan0     Link encap:UNSPEC
          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0
          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0
          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:3000
          RX bytes:116266821 TX bytes:8311736
</code></pre>
<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<pre><code class="language-sh">adb shell netcfg
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d
lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00
p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d
sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00
rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00
rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58
rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf
rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f
rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9
rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0
rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a
rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b
rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9
rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe
</code></pre>
<p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="mac-地址">Mac 地址</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell cat /sys/class/net/wlan0/address
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">f8:a9:d0:17:42:4d
</code></pre>
<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h3 id="cpu-信息">CPU 信息</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell cat /proc/cpuinfo
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">Processor       : ARMv7 Processor rev 0 (v7l)
processor       : 0
BogoMIPS        : 38.40

processor       : 1
BogoMIPS        : 38.40

processor       : 2
BogoMIPS        : 38.40

processor       : 3
BogoMIPS        : 38.40

Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt
CPU implementer : 0x51
CPU architecture: 7
CPU variant     : 0x2
CPU part        : 0x06f
CPU revision    : 0

Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)
Revision        : 000b
Serial          : 0000000000000000
</code></pre>
<p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 <code>Qualcomm MSM 8974</code>，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 <code>ARMv7 Processor rev 0 (v71)</code>。</p>
<h3 id="内存信息">内存信息</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell cat /proc/meminfo
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">MemTotal:        1027424 kB
MemFree:          486564 kB
Buffers:           15224 kB
Cached:            72464 kB
SwapCached:        24152 kB
Active:           110572 kB
Inactive:         259060 kB
Active(anon):      79176 kB
Inactive(anon):   207736 kB
Active(file):      31396 kB
Inactive(file):    51324 kB
Unevictable:        3948 kB
Mlocked:               0 kB
HighTotal:        409600 kB
HighFree:         132612 kB
LowTotal:         617824 kB
LowFree:          353952 kB
SwapTotal:        262140 kB
SwapFree:         207572 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:        265324 kB
Mapped:            47072 kB
Shmem:              1020 kB
Slab:              57372 kB
SReclaimable:       7692 kB
SUnreclaim:        49680 kB
KernelStack:        4512 kB
PageTables:         5912 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:      775852 kB
Committed_AS:   13520632 kB
VmallocTotal:     385024 kB
VmallocUsed:       61004 kB
VmallocChunk:     209668 kB
</code></pre>
<p>其中，<code>MemTotal</code> 就是设备的总内存，<code>MemFree</code> 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性">更多硬件与系统属性</h3>
<p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<pre><code class="language-sh">adb shell cat /system/build.prop
</code></pre>
<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody>
</table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<pre><code class="language-sh">adb shell cat /system/build.prop | grep ro.product.cpu.abi
</code></pre>
<p>示例输出：</p>
<pre><code class="language-sh">ro.product.cpu.abi=armeabi-v7a
ro.product.cpu.abi2=armeabi
</code></pre>
<h2 id="修改设置">修改设置</h2>
<p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h3 id="分辨率">分辨率</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell wm size 480x1024
</code></pre>
<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<pre><code class="language-sh">adb shell wm size reset
</code></pre>
<h3 id="屏幕密度-2">屏幕密度</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell wm density 160
</code></pre>
<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<pre><code class="language-sh">adb shell wm density reset
</code></pre>
<h3 id="显示区域">显示区域</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell wm overscan 0,0,0,200
</code></pre>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<pre><code class="language-sh">adb shell wm overscan reset
</code></pre>
<h3 id="关闭-usb-调试模式">关闭 USB 调试模式</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell settings put global adb_enabled 0
</code></pre>
<p>恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="允许禁止访问非-sdk-api">允许/禁止访问非 SDK API</h3>
<p>允许访问非 SDK API：</p>
<pre><code class="language-sh">adb shell settings put global hidden_api_policy_pre_p_apps 1
adb shell settings put global hidden_api_policy_p_apps 1
</code></pre>
<p>禁止访问非 SDK API：</p>
<pre><code class="language-sh">adb shell settings delete global hidden_api_policy_pre_p_apps
adb shell settings delete global hidden_api_policy_p_apps
</code></pre>
<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody>
</table>
<h3 id="状态栏和导航栏的显示隐藏">状态栏和导航栏的显示隐藏</h3>
<p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<pre><code class="language-sh">adb shell settings put global policy_control &lt;key-values&gt;
</code></pre>
<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<pre><code class="language-sh">adb shell settings put global policy_control immersive.full=*
</code></pre>
<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<pre><code class="language-sh">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3
</code></pre>
<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h2 id="实用功能">实用功能</h2>
<h3 id="屏幕截图">屏幕截图</h3>
<p>截图保存到电脑：</p>
<pre><code class="language-sh">adb exec-out screencap -p &gt; sc.png
</code></pre>
<p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<pre><code class="language-sh">adb shell screencap -p /sdcard/sc.png
</code></pre>
<p>然后将 png 文件导出到电脑：</p>
<pre><code class="language-sh">adb pull /sdcard/sc.png
</code></pre>
<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody>
</table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法：</p>
<p><em>Linux 和 Windows</em></p>
<pre><code class="language-sh">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png
</code></pre>
<p><em>Mac OS X</em></p>
<pre><code class="language-sh">adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png
</code></pre>
<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<pre><code class="language-sh">sed: RE error: illegal byte sequence
</code></pre>
<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<pre><code class="language-sh">brew install gnu-sed
</code></pre>
<h3 id="录制屏幕">录制屏幕</h3>
<p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<pre><code class="language-sh">adb shell screenrecord /sdcard/filename.mp4
</code></pre>
<p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<pre><code class="language-sh">adb pull /sdcard/filename.mp4
</code></pre>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>--size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>--bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>--time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>--verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody>
</table>
<h3 id="重新挂载-system-分区为可写">重新挂载 system 分区为可写</h3>
<p><strong>注：需要 root 权限。</strong></p>
<p>/system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<ol>
<li>
<p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：</p>
<pre><code class="language-sh">adb shell
su
</code></pre>
</li>
<li>
<p>查看当前分区挂载情况。</p>
<p>命令：</p>
<pre><code class="language-sh">mount
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">rootfs / rootfs ro,relatime 0 0
tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0
devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0
proc /proc proc rw,relatime 0 0
sysfs /sys sysfs rw,seclabel,relatime 0 0
selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0
debugfs /sys/kernel/debug debugfs rw,relatime 0 0
none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0
none /acct cgroup rw,relatime,cpuacct 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0
tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0
none /dev/memcg cgroup rw,relatime,memory 0 0
none /dev/cpuctl cgroup rw,relatime,cpu 0 0
none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0
none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0
none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0
/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0
/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0
/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0
</code></pre>
<p>找到其中我们关注的带 /system 的那一行：</p>
<pre><code class="language-sh">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0
</code></pre>
</li>
<li>
<p>重新挂载。</p>
<p>命令：</p>
<pre><code class="language-sh">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system
</code></pre>
<p>这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</p>
</li>
</ol>
<p>如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-wifi-密码">查看连接过的 WiFi 密码</h3>
<p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<pre><code class="language-sh">adb shell
su
cat /data/misc/wifi/*.conf
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">network={
	ssid=&quot;TP-LINK_9DFC&quot;
	scan_ssid=1
	psk=&quot;123456789&quot;
	key_mgmt=WPA-PSK
	group=CCMP TKIP
	auth_alg=OPEN
	sim_num=1
	priority=13893
}

network={
	ssid=&quot;TP-LINK_F11E&quot;
	psk=&quot;987654321&quot;
	key_mgmt=WPA-PSK
	sim_num=1
	priority=17293
}
</code></pre>
<p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p>
<p>如果 Android O 或以后，WiFi 密码保存的地址有变化，是在 <code>WifiConfigStore.xml</code> 里面</p>
<pre><code class="language-sh">adb shell
su
cat /data/misc/wifi/WifiConfigStore.xml
</code></pre>
<p>输出格式：</p>
<p>数据项较多，只需关注 <code>ConfigKey</code>（WiFi 名字）和 <code>PreSharedKey</code>（WiFi 密码）即可</p>
<pre><code class="language-xml">&lt;string name=&quot;ConfigKey&quot;&gt;&amp;quot;Wi-Fi&amp;quot;WPA_PSK&lt;/string&gt;
&lt;string name=&quot;PreSharedKey&quot;&gt;&amp;quot;931907334&amp;quot;&lt;/string&gt;
</code></pre>
<h3 id="设置系统日期和时间">设置系统日期和时间</h3>
<p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<pre><code class="language-sh">adb shell
su
date -s 20160823.131500
</code></pre>
<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机">重启手机</h3>
<p>命令：</p>
<pre><code class="language-sh">adb reboot
</code></pre>
<h3 id="检测设备是否已-root">检测设备是否已 root</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell
su
</code></pre>
<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h3 id="使用-monkey-进行压力测试">使用 Monkey 进行压力测试</h3>
<p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<pre><code class="language-sh">adb shell monkey -p &lt;packagename&gt; -v 500
</code></pre>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p>
<h3 id="开启关闭-wifi">开启/关闭 WiFi</h3>
<p><strong>注：需要 root 权限。</strong></p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<pre><code class="language-sh">adb root
adb shell svc wifi enable
</code></pre>
<p>关闭 WiFi：</p>
<pre><code class="language-sh">adb root
adb shell svc wifi disable
</code></pre>
<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h2 id="刷机相关命令">刷机相关命令</h2>
<h3 id="重启到-recovery-模式">重启到 Recovery 模式</h3>
<p>命令：</p>
<pre><code class="language-sh">adb reboot recovery
</code></pre>
<h3 id="从-recovery-重启到-android">从 Recovery 重启到 Android</h3>
<p>命令：</p>
<pre><code class="language-sh">adb reboot
</code></pre>
<h3 id="重启到-fastboot-模式">重启到 Fastboot 模式</h3>
<p>命令：</p>
<pre><code class="language-sh">adb reboot bootloader
</code></pre>
<h3 id="通过-sideload-更新系统">通过 sideload 更新系统</h3>
<p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li>
<p>重启到 Recovery 模式。</p>
<p>命令：</p>
<pre><code class="language-sh">adb reboot recovery
</code></pre>
</li>
<li>
<p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。</p>
<p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p>
</li>
<li>
<p>通过 adb 上传和更新系统。</p>
<p>命令：</p>
<pre><code class="language-sh">adb sideload &lt;path-to-update.zip&gt;
</code></pre>
</li>
</ol>
<h2 id="安全相关命令">安全相关命令</h2>
<h3 id="启用禁用-selinux">启用/禁用 SELinux</h3>
<p>启用 SELinux</p>
<pre><code class="language-sh">adb root
adb shell setenforce 1
</code></pre>
<p>禁用 SELinux</p>
<pre><code class="language-sh">adb root
adb shell setenforce 0
</code></pre>
<h3 id="启用禁用-dm_verity">启用/禁用 dm_verity</h3>
<p>启用 dm_verity</p>
<pre><code class="language-sh">adb root
adb enable-verity
</code></pre>
<p>禁用 dm_verity</p>
<pre><code class="language-sh">adb root
adb disable-verity
</code></pre>
<h2 id="更多-adb-shell-命令">更多 adb shell 命令</h2>
<p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h3 id="查看进程">查看进程</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell ps
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME
root      1     0     8904   788   ffffffff 00000000 S /init
root      2     0     0      0     ffffffff 00000000 S kthreadd
...
u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic
u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure
...
shell     8750  217   10640  740   00000000 b6f28340 R ps
</code></pre>
<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<h3 id="查看实时资源占用情况">查看实时资源占用情况</h3>
<p>命令：</p>
<pre><code class="language-sh">adb shell top
</code></pre>
<p>输出示例：</p>
<pre><code class="language-sh">User 0%, System 6%, IOW 0%, IRQ 0%
User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307

  PID PR CPU% S  #THR     VSS     RSS PCY UID      Name
 8763  0   3% R     1  10640K   1064K  fg shell    top
  131  0   3% S     1      0K      0K  fg root     dhd_dpc
 6144  0   0% S   115 1682004K 115916K  fg system   system_server
  132  0   0% S     1      0K      0K  fg root     dhd_rxf
 1731  0   0% S     6  20288K    788K  fg root     /system/bin/mpdecision
  217  0   0% S     6  18008K    356K  fg shell    /sbin/adbd
 ...
 7779  2   0% S    19 1538748K  48896K  bg u0_a71   com.sohu.inputmethod.sogou:classic
 7963  0   0% S    18 1561916K  59568K  fg u0_a58   org.mazhuang.boottimemeasure
 ...
</code></pre>
<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody>
</table>
<p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p>
<pre><code class="language-sh">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]
    -m num  最多显示多少个进程
    -n num  刷新多少次后退出
    -d num  刷新时间间隔（单位秒，默认值 5）
    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）
    -t      显示线程信息
    -h      显示帮助文档
</code></pre>
<h3 id="查看进程-uid">查看进程 UID</h3>
<p>有两种方案：</p>
<ol>
<li>
<p><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=</code></p>
<p>如：</p>
<pre><code class="language-sh">$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId=
   userId=10394
</code></pre>
</li>
<li>
<p>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code></p>
<p>如：</p>
<pre><code class="language-sh">$ adb shell
gemini:/ $ ps | grep org.mazhuang.guanggoo
u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo
gemini:/ $ cat /proc/28635/status | grep Uid
Uid:    10394   10394   10394   10394
gemini:/ $
</code></pre>
</li>
</ol>
<h3 id="其它">其它</h3>
<p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式/访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody>
</table>
<h2 id="常见问题">常见问题</h2>
<h3 id="启动-adb-server-失败">启动 adb server 失败</h3>
<p><strong>出错提示</strong></p>
<pre><code class="language-sh">error: protocol fault (couldn't read status): No error
</code></pre>
<p><strong>可能原因</strong></p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p><strong>解决方案</strong></p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<pre><code class="language-sh">netstat -ano | findstr LISTENING

...
TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548
...
</code></pre>
<p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<pre><code class="language-sh">taskkill /PID 1548
</code></pre>
<p>然后再启动 adb 就没问题了。</p>
<h3 id="comandroidddmlibadbcommandrejectedexception">com.android.ddmlib.AdbCommandRejectedException</h3>
<p>在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示：</p>
<pre><code>com.android.ddmlib.AdbCommandRejectedException: device unauthorized.
This adb server's $ADB_VENDOR_KEYS is not set
Try 'adb kill-server' if that seems wrong.
Otherwise check for a confirmation dialog on your device.
</code></pre>
<p>在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。</p>
<p>于是删除该模拟器后重新下载安装一次，这次就正常了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TestNG集成allure]]></title>
        <id>https://theotop97.github.io/post/testng-ji-cheng-allure/</id>
        <link href="https://theotop97.github.io/post/testng-ji-cheng-allure/">
        </link>
        <updated>2021-05-22T14:04:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-maven">1 Maven</h2>
<h3 id="11-指定testngxml的路径">1.1 指定testng.xml的路径</h3>
<pre><code class="language-shell">mvn clean test -Dsurefire.suiteXmlFiles=src/main/resources/testng.xml
</code></pre>
<h3 id="12-生成allure报告">1.2 生成allure报告</h3>
<ul>
<li>
<p>生成在线html，ctrl+c终止后会无法访问：</p>
<pre><code class="language-shell">mvn io.qameta.allure:allure-maven:serve
</code></pre>
<ul>
<li>
<p>当配置好了allure环境后，可使用如下方式：</p>
<pre><code class="language-shell">allure serve allure-results
</code></pre>
</li>
</ul>
</li>
<li>
<p>生成本地html文件(需要配置allure环境)</p>
<pre><code class="language-shell">allure generate --clean target/allure-results 
</code></pre>
</li>
</ul>
<h2 id="2-gradle">2 Gradle</h2>
<ul>
<li>
<p>生成allure-results(allure自己收集的数据，以json文件保存),build.gradle需要配置useTestNg</p>
<pre><code>gradlew clean test
</code></pre>
</li>
<li>
<p>生成在线报告</p>
<blockquote>
<p>根据自己工程的目录来编写路径</p>
</blockquote>
<pre><code>allure serve test-case/allure-results
</code></pre>
</li>
<li>
<p>生成本地报告</p>
<pre><code>allure generate test-case/allure-results report --clean -o test-case/allure-report
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Monkey的使用]]></title>
        <id>https://theotop97.github.io/post/Android-Monkey/</id>
        <link href="https://theotop97.github.io/post/Android-Monkey/">
        </link>
        <updated>2021-05-17T16:33:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="monkey基础知识">Monkey基础知识</h1>
<h2 id="11-monkey概况">1.1 Monkey概况</h2>
<p>在Android的官方自动化测试领域有一只非常著名的“猴子”叫Monkey，这只“猴子”一旦启动，就会让被测的Android应用程序像 猴子一样活蹦乱跳，到处乱跑。人们常用这只“猴子”来对被测程序进行压力测试，检查和评估被测程序的稳定性。</p>
<p>Android官方对这只“猴子”的描述是这样的:Monkey是Google提供的一个命令行工具，可运行在模拟器或实际设备中。它向系统发送伪随机的用户事件，模拟用户的按键输入、触摸屏输入、手势输入等，从而对正在运行的应用程序进行压力测试，目的是看设备多长时间会出现异常，并观察系统的稳定性和容错性能。</p>
<p>Monkey程序是Android系统自带的，其启动脚本是位于Android系统的/system/bin目录的monkey文件，其jar包是位于Android系统 的/system/framework目录的monkey.jar文件。用户主要是通过adb命令来启动Monkey的，Monkey在运行时，会根据命令行参数的配置，生成伪随机的事件流，并在Android设备上执行对应的测试事件。同时，Monkey还会对测试系统进行监测，当出现以下三种情况时会进行特殊处理:</p>
<p>1、如限定了Monkey运行在特定包上，当监测到试图转到其他包的操作，将对其进行阻止。</p>
<p>2、如应用程序崩溃或接收到任何失控异常，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</p>
<p>3、如果应用程序发生了程序无响应(application not responding)的错误，Monkey将记录对应的错误日志，并根据命令行参数判断是停止运行还是继续运行。</p>
<p>按照选定的不同级别的反馈信息，在Monkey中还可以看到其执行过程报告和生成的事件。</p>
<h2 id="12-monkey参数">1.2 Monkey参数</h2>
<p>Monkey启动的命令行脚本为:</p>
<p><code>monkey [options] &lt;count&gt;</code></p>
<p>其中，options表示Monkey执行的可配置参数，是可选项(如果不指定options，Monkey将以无反馈模式启动，并把事件任意发送到安装在目标环境中的全部包);count表示Monkey执行的事件数，为必选项。</p>
<p>Options可简单划分为五类:</p>
<ul>
<li>基本配置类参数。</li>
<li>事件类型和频率参数。</li>
<li>约束限制类参数。</li>
<li>调试类参数。</li>
<li>其他参数。</li>
</ul>
<h3 id="121-基本配置类参数">1.2.1 基本配置类参数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">--help</td>
<td style="text-align:left">输出monkey的命令行使用方法</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td style="text-align:left">表示反馈信息的级别，Monkey命令行中每增加一个-v参数，Monkey日志反馈信息的级别会对应增加一个Level。Level 0 (缺省值)除启动提示、测试完成和最终结果之外，提供较少信息。Level 1( -v-v) 提供较为详细的测试信息，如逐个发送到Activity的事件。Level2 ( -v -v -v)提供更加详细的设置信息，如测试中被选中的或未被选中的Activity等<br/>   举例: adb shell monkey -v -v 10</td>
</tr>
</tbody>
</table>
<h3 id="122-事件类型和频率参数">1.2.2 事件类型和频率参数</h3>
<p>Monkey的事件类参数的作用是对随机事件进行调控，从而使其遵照设定运行，如设置各种事件的百分比、设置事件生成所使用的种子值等。频率参数主要限制事件执行的时间间隔。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-s&lt;seed&gt;</td>
<td style="text-align:left">伪随机数生成器的种子值。如果用相同的种子值再次运行Monkey,它将生成相同的事件序列<br/>举例adb shell monkey -1111 -v 10</td>
</tr>
<tr>
<td style="text-align:center">--throttle&lt;毫秒数&gt;</td>
<td style="text-align:left">在事件之间插入固定延迟。通过这个选项可以减缓Monkey的执行速度。如果不指定该选项，Monkey 将不会被延迟，事件将尽可能快地被生成</td>
</tr>
<tr>
<td style="text-align:center">--pct-touch&lt;百分比&gt;</td>
<td style="text-align:left">调整触摸事件的百分比(触摸事件是一个 down-up事件，它发生在屏幕上的某单一位置)</td>
</tr>
<tr>
<td style="text-align:center">--pct-motion&lt;百分比&gt;</td>
<td style="text-align:left">调整动作事件的百分比(动作事件由屏幕上某处的一个down事件、一系列的伪随机事件和一个 up事件组成)</td>
</tr>
<tr>
<td style="text-align:center">--pct-pinchzoom&lt;百分比&gt;</td>
<td style="text-align:left">调整二指缩放事件的百分比(二指缩放事件即智能机上的放大缩小手势操作)</td>
</tr>
<tr>
<td style="text-align:center">--pct-trackball&lt;百分比&gt;</td>
<td style="text-align:left">调整轨迹事件的百分比(轨迹事件由一个或几个随机的移动组成，有时还伴随点击)</td>
</tr>
<tr>
<td style="text-align:center">--pct-rotation&lt;百分比&gt;</td>
<td style="text-align:left">调整屏幕旋转事件的百分比(横屏和竖屏)</td>
</tr>
<tr>
<td style="text-align:center">--pct-nav&lt;百分比&gt;</td>
<td style="text-align:left">调整“基本”导航事件的百分比(导航事件由来自方向输入设备的up、down、left、right 组成)</td>
</tr>
<tr>
<td style="text-align:center">--pct-majornav&lt;百分比&gt;</td>
<td style="text-align:left">调整“主要”导航事件的百分比(这些导航事件通常引发图形界面中的动作，如键盘的中间按键、回退按键、菜单按键)</td>
</tr>
<tr>
<td style="text-align:center">--pct-syskeys&lt;百分比&gt;</td>
<td style="text-align:left">调整“系统”按键事件的百分比(这些按键通常被保留，由系统使用，如Home、Back、Start Call、End Call及音量控制键)</td>
</tr>
<tr>
<td style="text-align:center">--pct-appswitch&lt;百分比&gt;</td>
<td style="text-align:left">调整启动Activity的百分比(在随机间隔里，Monkey通过调用startActivity方法最大限度地开启该package下的全部Activity 的一种方法)</td>
</tr>
<tr>
<td style="text-align:center">--pct-flip&lt;百分比&gt;</td>
<td style="text-align:left">调整键盘事件的百分比(键盘事件如点击输入框、键盘弹起、点击输人框以外区域、键盘收回等)</td>
</tr>
<tr>
<td style="text-align:center">--pct-anyevent&lt;百分比&gt;</td>
<td style="text-align:left">调整其他类型事件的百分比(包罗了所有其他类型的事件，如按键、其他不常用的设备按钮等)</td>
</tr>
</tbody>
</table>
<h3 id="123-约束限制类参数">1.2.3 约束限制类参数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">                      -p&lt; 包名  &gt;      </td>
<td style="text-align:left">如果用此参数指定了一个或几个包，Monkey 将只允许系统启动这些包里的Activity。 如果应用程序还需要访问其他包里的Activity (如选择一个联系人)， 那些包也需要在此同时指定。如果不指定任何包，Monkey将允许系统启动全部包里的Activity。如果要指定多个包，需要使用多个-p选项，每个-p选项只能用于一个包</td>
</tr>
<tr>
<td style="text-align:center">-c&lt;类别名&gt;</td>
<td style="text-align:left">如果用此参数指定了一个或几个类别( Category), Monkey 将只允许系统启动被这些类别中的某个类别列出的Activity。如果不指定任何类别，Monkey 将选择下列类别中列出的Activity:Intent.CATEGORY_ LAUNCHER或Intent.CATEGORY_ MONKEY。要指定多个类别，需要使用多个-c选项，每个-c选项只能用于一个类别</td>
</tr>
</tbody>
</table>
<h3 id="124-调试类参数">1.2.4 调试类参数</h3>
<p>通过调试类命令，可以对Monkey进行一些简单的调试，可以快速定位Monkey执行过程中的一些问题。如果用户想监控应用程序所调用的包之间的转换，则可以用--dbg-no-events参数;如果用户想监控内存泄漏，可以用--hprof参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">--dbg-no-events</td>
<td>设置此选项，Monkey 将执行初始启动，进入一个测试Activity,不会再进一步生成事件。为了得到最佳结果，把它与-V、一个或几个包约束，以及一个保持Monkey运行30秒或更长时间的非零值联合起来，从而提供一个可以监视应用程序所调用的包之间的转换的环境</td>
</tr>
<tr>
<td style="text-align:center">--hprof</td>
<td>设置此选项，将在Monkey事件执行之前和执行之后生成内存快照文件存放于手机的data/misc目录。通过对比执行前后的内存快照文件，可以协助定位内存泄漏问题。由于内存快照文件比较大，所以要小心使用.</td>
</tr>
<tr>
<td style="text-align:center">--ignore-crashes</td>
<td>通常，当应用程序崩溃或发生任何失控异常时，Monkey 将停止运行。如果设置此选项，Monkey 将继续向系统发送事件，直到计数完成</td>
</tr>
<tr>
<td style="text-align:center">--ignore-timeouts</td>
<td>通常，当应用程序发生任何超时错误(如出现“Application Not Responding对话框)时，Monkey 将停止运行。如果设置了此选项，Monkey将继续向系统发送事件，直到计数完成</td>
</tr>
<tr>
<td style="text-align:center">--ignore-security-exceptions</td>
<td>通常，当应用程序发生许可错误(如启动一个需要某些许可的Activity),Monkey将停止运行。如果设置了此选项，Monkey 将继续向系统发送事件，直到计数完成</td>
</tr>
<tr>
<td style="text-align:center">--kill-process-after-error</td>
<td>通常，当Monkey由于一个错误而停止时，出错的应用程序将继续处于运行状态。当设置了此选项时，将会通知系统停止发生错误的进程</td>
</tr>
<tr>
<td style="text-align:center">--monitor-native-crashes</td>
<td>监视并报告Android系统中本地代码的崩溃事件</td>
</tr>
<tr>
<td style="text-align:center">--wait-dbg</td>
<td>停止执行中的Monkey，直到有调试器和它相连接</td>
</tr>
</tbody>
</table>
<h3 id="125-其他参数">1.2.5 其他参数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">--pkg-blacklist-file&lt;黑名单文件&gt;</td>
<td>限制Monkey不测试于指定黑名单文档中记录的包( Package)。若没有使用这个参数，Monkey会测试系统内所有的包。若使用了该参数，可通过在黑名单文档内记录所有不要测试的包名称，来限制Monkey的执行范围。黑名单文档中每一-行只能放一个包名</td>
</tr>
<tr>
<td style="text-align:center">--pkg-whitelist-file&lt;白名单文件&gt;</td>
<td>限制Monkey只测试于指定的白名单文档中记录的包( Package)。若没有使用这个参数，Monkey会测试系统内所有的包。若使用了该参数，可通过在白名单文档内记录所有要测试的包名，来限制Monkey的执行方位。白名单文档中每一-行只能放一个包名<br/>注意:若要测试的包与其他的包有关联，则必须一起指定这些包来执行这项参数</td>
</tr>
<tr>
<td style="text-align:center">-f&lt;脚本文件&gt;</td>
<td>指定Monkey执行用户自定义的脚本文件</td>
</tr>
</tbody>
</table>
<h2 id="13-monkey事件">1.3 Monkey事件</h2>
<p>Monkey所执行的随机事件流中包含11大事件，分别是触摸事件、手势事件、二指缩放事件、轨迹事件、屏幕旋转事件、基 本导航事件、主要导航事件、系统按键事件、启动Activity事件、键盘事件、其他类型事件。Monkey通过这11大事件来模拟用户 的常规操作，对手机App进行稳定性测试。</p>
<h3 id="131-触摸事件">1.3.1 触摸事件</h3>
<p>触摸事件是指在屏幕某处按下并抬起的操作，可通过--pct-touch参数来配置其事件百分比。从Monkey执行该事件对外输出的</p>
<p>日志可以看到:</p>
<pre><code>:Sending Touch (ACTION_DOWN): 0,(444.0,1716.0) 
:Sending Touch (ACTION_UP): 0,(447.18365,1728,0087)
</code></pre>
<p>该事件由一组Touch(ACTION_DOWN)和Touch(ACTION_UP)事件组成，在手机上看到实际操作类似于点击。</p>
<h3 id="132-手势事件">1.3.2 手势事件</h3>
<p>手势事件是指在屏幕某处的按下、随机移动、抬起的操作，即直线滑动操作。可通过--pct-motion参数来配置其事件百分比。 从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Touch (ACTION_DOWN): 0:(282.0,750.0) 
:Sending Touch (ACTION_MOVE): 0:(281.0507,745.5253) 
:Sending Touch (ACTION_MOVE): 0:(274.9443,743.3276) 
:Sending Touch (ACTION_MOVE): 0:(269.18774,738.50525) 
:Sending Touch (ACTION_MOVE): 0:(260.14917,733.6212) 
:Sending Touch (ACTION_UP): 0:(254.1414,730.6132)
</code></pre>
<p>该事件是由一个ACTION_DOWN事件、一系列ACTION_MOVE事件和一个ACTION_UP事件组成的，在手机上看到的实际操 作是一个没有拐弯的直线滑动操作。</p>
<h3 id="133-二指缩放事件">1.3.3 二指缩放事件</h3>
<p>二指缩放事件是指在屏幕上的两处同时按下，并同时移动，最后同时抬起的操作，即智能机上的放大缩小手势操作。可通</p>
<p>过--pct-pinchzoom参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Touch (ACTION_DOWN): 0:(274.0,193.0)
:Sending Touch (ACTION_POINTER_DOWN 1): 0:(272.80875,198.17978) 1:(26.0,312.0) 
:Sending Touch (ACTION_MOVE): 0:(251.31396,198.5104) 1:(24.973522,308.64676)
:Sending Touch (ACTION_MOVE): 0:(240.28494,202.44012) 1:(23.442032,307.8576)
:Sending Touch (ACTION_MOVE): 0:(221.90855,206.75597) 1:(22.903313,306.47507) 
:Sending Touch (ACTION_MOVE): 0:(210.28592,212.24286) 1:(17.78174,303.11304)
:Sending Touch (ACTION_POINTER_UP 1): 0:(171.06334,236.1724) 1:(10.3147135,293.79877) :Sending Touch (ACTION_UP): 0:(161.06638,240.22447)
</code></pre>
<p>该事件起始是一个ACTION_DOWN事件和一个ACTION_POINTER_DOWN事件，即模拟两个手指同时点下;中间是一系列 的ACTION_MOVE事件，即两个手指同时在屏幕上直线滑动;结束是由一个ACTION_POINTER_UP事件和一个ACTION_UP事件 组成的，即两个手指同时放开。</p>
<h3 id="134-轨迹事件">1.3.4 轨迹事件</h3>
<p>轨迹事件是由一个或多个随机的移动组成的，有时会伴随着点击。很早之前的Android手机带有轨迹球，这个事件就是模拟 的轨迹球的操作。现在的手机几乎都没有轨迹球，但轨迹球事件中包含曲线滑动操作，如果被测程序需要曲线滑动时可以选用此 参数。可通过--pct-trackball参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Trackball (ACTION_MOVE): 0:(2.0,3.0)
:Sending Trackball (ACTION_MOVE): 0:(-1.0,4.0) 
:Sending Trackball (ACTION_MOVE): 0:(2.0,-3.0)
</code></pre>
<p>该事件是由一系列的Trackball(ACTION_MOVE)事件组成的，观察手机上的操作，即为一系列的曲线滑动操作。</p>
<h3 id="135-屏幕旋转事件">1.3.5 屏幕旋转事件</h3>
<p>屏幕旋转事件是一个隐藏事件，在Android官方文档中并没有记录这个事件。它其实是模拟的Android手机的横屏和竖屏切 换。可通过--pct-rotation参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending rotation degree=1, persist=false 
:Sending rotation degree=3, persist=true 
:Sending rotation degree=2, persist=true 
:Sending rotation degree=0, persist=true
</code></pre>
<p>该事件由一个rotation事件组成，其中degree表示的是旋转方向，顺时针旋转，0表示旋转90度的方向，1表示旋转180度的方 向，2表示旋转270度的方向，3表示旋转360度的方向。在执行过程中，可以看到手机屏幕在横竖屏之间不断地切换。</p>
<h3 id="136-基本导航事件">1.3.6 基本导航事件</h3>
<p>基本导航事件是指点击方向输入设备的上、下、左、右按键的操作，现在手机上很少有上、下、左、右按键，这种事件一般 用得比较少。可通过--pct-nav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Key (ACTION_DOWN): 19   // KEYCODE_DPAD_UP
:Sending Key (ACTION_UP): 19     // KEYCODE_DPAD_UP
:Sending Key (ACTION_DOWN): 20   // KEYCODE_DPAD_DOWN
:Sending Key (ACTION_UP): 20     // KEYCODE_DPAD_DOWN
:Sending Key (ACTION_DOWN): 21   // KEYCODE_DPAD_LEFT 
:Sending Key (ACTION_UP): 21     // KEYCODE_DPAD_LEFT
:Sending Key (ACTION_DOWN): 22   // KEYCODE_DPAD_RIGHT
:Sending Key (ACTION_UP): 22     // KEYCODE_DPAD_RIGHT
</code></pre>
<p>该事件是由一个Key(ACTION_DOWN)和一个Key(ACTION_UP)组成的，点击的就是上、下、左、右四个方向按键。</p>
<h3 id="137-主要导航事件">1.3.7 主要导航事件</h3>
<p>主要导航事件是指点击“主要导航”按键的操作，这些按键通常会导致UI界面中的动作，如5-way键盘的中间键、回退按键、 菜单按键。可通过--pct-majornav参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Key (ACTION_DOWN): 23  // KEYCODE_DPAD_CENTER
:Sending Key (ACTION_UP): 23    // KEYCODE_DPAD_CENTER
:Sending Key (ACTION_DOWN): 82  // KEYCODE_MENU
:Sending Key (ACTION_UP): 82    // KEYCODE_MENU
</code></pre>
<p>该事件是由一个Key(ACTION_DOWN)和一个Key(ACTION_UP)组成的，点击的按键就是中间键和菜单键。</p>
<h3 id="138-系统按键事件">1.3.8 系统按键事件</h3>
<p>系统按键事件是指点击系统保留使用的按键的操作，如点击Home键、返回键、音量调节键等。可通过--pct-syskeys参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Key (ACTION_DOWN): 5   // KEYCODE_CALL
:Sending Key (ACTION_UP): 5     // KEYCODE_CALL
:Sending Key (ACTION_DOWN): 4   // KEYCODE_BACK
:Sending Key (ACTION_UP): 4     // KEYCODE_BACK
:Sending Key (ACTION_DOWN): 3   // KEYCODE_HOME
:Sending Key (ACTION_UP): 3     // KEYCODE_HOME
:Sending Key (ACTION_DOWN): 24  // KEYCODE_VOLUME_UP
:Sending Key (ACTION_UP): 24    // KEYCODE_VOLUME_UP
:Sending Key (ACTION_DOWN): 25  // KEYCODE_VOLUME_DOWN
:Sending Key (ACTION_UP): 25    // KEYCODE_VOLUME_DOWN
</code></pre>
<p>该事件是由一个Key(ACTION_DOWN)和一个Key(ACTION_UP)组成的，点击的就是上面说到的几个系统按键。</p>
<h3 id="139-启动activity事件">1.3.9 启动Activity事件</h3>
<p>启动Activity事件是指在手机上启动一个Activity的操作。在随机的时间间隔中，Monkey将执行一个startActivity()方法，作为 最大限度上覆盖被测包中全部Activity的一种方法。可通过--pct-appswitch参数来配置其事件百分比。从Monkey执行该事件对外输 出的日志可以看到:</p>
<pre><code>:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent. category.LAUNCHER;launchFlags=0x10200000;component=com.android.settings/. Settings;end
// Allowing start of Intent { act=android.intent.action.MAIN cat=[android. intent.category.LAUNCHER] cmp=com.android.settings/.Settings } in package com. android.settings
</code></pre>
<p>该事件是由一个Switch操作组成的，从手机上看，上面的操作实际是打开了com.android.settings这个应用的一个 com.android.settings.Settings的Activity界面。</p>
<h3 id="1310-键盘事件">1.3.10 键盘事件</h3>
<p>键盘事件主要是一些与键盘相关的操作。比如点击输入框、键盘弹起、点击输入框以外区域、键盘收回等。可通过--pct-flip</p>
<p>参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Flip keyboardOpen=false
:Sending Flip keyboardOpen=true
</code></pre>
<p>如日志所示，这里主要是键盘的打开和关闭操作。</p>
<h3 id="1311-其他类型事件">1.3.11 其他类型事件</h3>
<p>其他类型事件包括了除前面提到的10种事件外其他所有的事件，如按键、其他不常用的设备上的按钮等。可通过--pct- anyevent参数来配置其事件百分比。从Monkey执行该事件对外输出的日志可以看到:</p>
<pre><code>:Sending Key (ACTION_DOWN): 59    // KEYCODE_SHIFT_LEFT
:Sending Key (ACTION_UP): 59      // KEYCODE_SHIFT_LEFT 
:Sending Key (ACTION_DOWN): 138   // KEYCODE_F8
:Sending Key (ACTION_UP): 138     // KEYCODE_F8
:Sending Key (ACTION_DOWN): 45    // KEYCODE_Q
:Sending Key (ACTION_UP): 45      // KEYCODE_Q
:Sending Key (ACTION_DOWN): 192   // KEYCODE_BUTTON_5
:Sending Key (ACTION_UP): 192     // KEYCODE_BUTTON_5...
</code></pre>
<p>该事件是由一个Key(ACTION_DOWN)和一个Key(ACTION_UP)组成的，点击的按键就是其他的一些系统按键，如字母按键、数字按键等。因为现在手机很少带字母按键或数字按键，所以这个事件一般使用得比较少。</p>
<h2 id="14-monkey启动">1.4 Monkey启动</h2>
<p>Monkey启动方式很简单:先连接被测手机到PC上，然后打开CMD命令行窗口输入对应的adb命令行即可。通过命令行启动Monkey有两种方式:</p>
<ul>
<li>直接PC启动</li>
</ul>
<pre><code>&gt; adb shell monkey [options] &lt;count&gt;
</code></pre>
<ul>
<li>Shell端启动</li>
</ul>
<pre><code>&gt;adb shell
&gt;monkey [options] &lt;count&gt;
</code></pre>
<p>这两者的区别是，通过PC端启动，Monkey运行日志可以保存在PC上;通过Shell端启动，Monkey运行日志可以保存在手机里</p>
<blockquote>
<p>Monkey启动后会不断地向被测对象发送随机事件流，直到事件执行完毕或者发生异常时才停止。在Monkey运行过程中，即便断开与PC的连接，Monkey依然可以在手机上继续运行。</p>
</blockquote>
<p>停止Monkey的方法是:直接杀掉手机上的Monkey进程。具体方法如下:</p>
<pre><code>&gt;adb shell ps |grep monkey
</code></pre>
<p>获取到com.android.commands.monkey的进程ID</p>
<pre><code>&gt;adb shell kill pid
</code></pre>
<p>下面来看一个最简单的Monkey命令行示例:</p>
<pre><code>&gt; adb shell monkey -v 10
</code></pre>
<p>通过该命令启动Monkey后，Monkey向被测手机的Android系统发送10条随机事件流。当启动运行Monkey测试后，手机上会开始执行Monkey测试， 同时在命令行窗口输出日志，执行完成后，可以看到Monkey的日志信息</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/05/19/pgHnoYwGPBF1xv4.png" alt="image.png" loading="lazy"></figure>
<h2 id="15-monkey测试方法">1.5 Monkey测试方法</h2>
<h3 id="151-monkey测试实例">1.5.1 Monkey测试实例</h3>
<p><strong>1.常规的稳定性测试</strong></p>
<p>被测程序是Android应用(App)，希望通过Monkey来模拟用户长时间的随机操作，检查被测应用是否会出现异常(应用崩溃或者无响应)。</p>
<p>测试脚本:</p>
<pre><code>adb shell monkey -p com.xxx.xxx --pct-touch 40 --pct-motion 25 --pct-appswitch 10 --pct-rotation 5 -s 12358 --throttle 400 --ignore-crashes --ignore-timeouts -v 500000
</code></pre>
<p>显而易见，这个Monkey测试的命令相比上面提到的要复杂得多，主要是对一些操作事件做了限制，从而减少了Monkey伪随机化的无效操作。这体现在以下几个方面。</p>
<p>1)使用-p参数来制定测试应用的包名(Package)</p>
<p>因为被测程序是一个特定的Android应用程序，需要指定被测程序的包名。指定包名后，Monkey会根据包名找到对应的应用，并启动其main activity，然后执行Monkey测试。</p>
<p>2)使用--pct-xxx参数限制Monkey执行的事件类型和占比</p>
<p>前面已经说了，这个测试的目的是希望模拟用户操作，因此需要让Monkey执行的事件尽可能地接近用户的常规操作，这样才可以 最大限度地发现用户使用过程中可能出现的问题。因此需要对Monkey执行的事件百分比做一些调整。</p>
<p>触摸事件和手势事件是用户最常见的操作，所以通过--pct-touch和--pct-motion将这两个事件的占比调整到40%与25%;目标应用包 含了多个Activity，为了能覆盖大部分的Activity，所以通过--pct-appswitch将Activity切换的事件占比调整到10%;被测应用之前在测试中 出现过不少横竖屏之间切换的问题，这个场景也必须关注，因此通过--pct-rotation把横竖屏切换事件调整到10%。</p>
<p>3)使用-s参数来指定命令执行的seed值</p>
<p>Monkey会根据seed值来生成对应事件流，同一个seed生成的事件流是完全相同的。这里指定了seed值，是为了测试发现问题时，便于进行问题复现。</p>
<p>4)使用--throttle参数来控制Monkey每个操作之间的时间间隔</p>
<p>指定操作之间的时间间隔，一方面是希望能更接近用户的操作场景，正常用户操作都会有一定的时间间隔;另一方面也是不希望 因为过于频繁的操作而导致系统崩溃，尤其是在比较低端的手机上执行测试时。因此通过--throttle设置Monkey每个操作固定延迟0.4 秒。</p>
<p>5)使用--ignore-crash和--ignore-timeouts参数使Monkey遇到意外时能继续执行</p>
<p>在执行Monkey测试时，会因为应用的崩溃或没有响应而意外终止，所以需要在命令中增加限制参数--ignore-crash和--ignore-timeouts，让Monkey在遇到崩溃或没有响应的时候，能在日志中记录相关信息，并继续执行后续的测试。</p>
<p>6)使用-v指定log的详细级别</p>
<p>Monkey的日志输出有3个级别:默认的是level 0，-v日志级别为level 1，-v-v日志级别为level 2。日志的级别越高，其详细程度也越高。为了方便问题的定位，将日志级别设置为level2。</p>
<p>在常规的稳定性测试中，虽然可以自定义各种事件的操作占比，但毕竟是随机事件流。在实际测试过程中，难免会遇到Monkey点了我们不希望它点击的地方，比如误点了工具栏导致网络断开的情况等。后续会介绍如何解决wifi重连的问题。</p>
<p><strong>2.自定义脚本的稳定性测试</strong></p>
<p>常规Monkey测试执行的是随机的事件流，但如果只是想让Monkey测试某个特定场景(执行固定的事件流)呢?这时候就需要用 到自定义脚本了，Monkey支持执行用户自定义脚本的测试，用户只需要按照Monkey脚本的规范编写好脚本，存放到手机上，启动 Monkey通过-f scriptfile参数调用脚本即可。</p>
<pre><code>#头文件，控制Monkey发送消息的参数，固定写即可
#脚本类型，一般不用更改
type=raw events 
#脚本执行次数，但是由于Monkey命令本身可以指定执行次数，所以这里的设置是不生效的 
count=10
#命令执行速率，速率也可以通过 Monkey命令设置，这里的设置是不生效的
speed=1.0 
#以下为Monkey命令 
start data&gt;&gt;
LaunchActivity( pkg_name,cl_name)
DispatchPress(KEYCODE_HOME)...
</code></pre>
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LaunchActivity(Pkg_name,cl_name)</td>
<td>启动被测应用的某个Activity<br/>Pkg_ name:包名<br/>cl name: Activity 名</td>
</tr>
<tr>
<td>Tap(x,y,tapDuration)</td>
<td>模拟一次手指单击事件<br/>X:<br/>点击的横坐标<br/>y:点击的纵坐标</td>
</tr>
<tr>
<td>DispatchPress(KeyName)</td>
<td>模拟按键点击<br/>keyName:按键的名称</td>
</tr>
<tr>
<td>RotateScreen(rotationDegree,peresist)</td>
<td>模拟旋转屏幕<br/>rotationDegree:用0 ~ 3分别表示顺时针旋转的四个方向<br/>peresist:是否存留</td>
</tr>
<tr>
<td>DispatchFlip(true/false)</td>
<td>打开或关闭软键盘</td>
</tr>
<tr>
<td>LongPress()</td>
<td>长按两秒</td>
</tr>
<tr>
<td>PressAndHold(x,y,pressDuration)</td>
<td>模拟长按事件:即单指按下一段时间， 再抬起<br/>X:点击的横坐标<br/>y:点击的纵坐标<br/>pressDuration:点击时长，单位是ms</td>
</tr>
<tr>
<td>DispatchString(input)</td>
<td>输入字符串<br/>input:输入内容</td>
</tr>
<tr>
<td>Drag(xStrat,yStart,xEnd,yEnd,stepCount)</td>
<td>模拟拖动操作:即单指按下、拖动、放开<br/>xStart、yStart:起始的横坐标和纵坐标<br/>xEnd、yEnd:结束的横坐标和纵坐标<br/>stepCount:移动的事件数(可理解为移动速度)</td>
</tr>
<tr>
<td>PinchZoom(pt1xStart,pt1yStart,<br/>pt1xEnd,pt1yEnd,pt2xStart,pt2yStart,<br/>pt2xEnd,pt2yEnd,stepCount)</td>
<td>模拟缩放手势:即两个手指同时按下并移动，再同时放开<br/>pt1xStart、ptlyStart: 手指1起始的横坐标和纵坐标<br/>pt1xEnd、pt1yEnd: 手指1结束的横坐标和纵坐标<br/>pt2xStart、pt2yStart: 手指2起始的横坐标和纵坐标<br/>pt2xEnd、pt2yEnd:手指2结束的横坐标和纵坐标<br/>stepCount:移动的事件数(可理解为移动速度,stepCount越大移动速度越慢)</td>
</tr>
<tr>
<td>UserWait(sleepTime)</td>
<td>设置等待时间<br/>sleepTime:等待的时间，单位是ms</td>
</tr>
<tr>
<td>DeviceWakeUp()</td>
<td>唤醒屏幕</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Monkey脚本只能通过坐标的方式来定位点击和移动事件的屏幕位置，这里就需要提前获取坐标信息。获取坐标信息的方法很多，最简单的方法就是打开手机中的开发人员选项，打开“显示指针位置”。随后，在屏幕上的每次操作，在导航栏上都会显示坐标信息。</p>
</blockquote>
<p>下面来看一个简单的例子:</p>
<p>这里要测试的是“设置”，测试的操作是打开“设置”，点击输入框，输入“”，点击搜索。搜索完成后，点击返回键返回应用宝首页。</p>
<p>首先，将在本地编写需要的测试脚本命名为monkey.script(文件格式无要求)，脚本内容如下</p>
<pre><code class="language-shell">#启动测试
type = user 
count = 49 
speed = 1.0 
start data &gt;&gt; 


#启动设置
LaunchActivity(com.android.settings,com.android.settings.Settings) 
UserWait(2000)


#点击搜索按钮
Tap(840,820,500) 
UserWait(2000) 


#点击搜索栏
Tap(200,150,1000)


#输入字母“theo”
DispatchString(theo) 
UserWait(2000) 


#点击搜索
Tap(975,2060,1000) 
UserWait(2000) 


#点击返回键返回首页
DispatchPress(KEYCODE_BACK)
</code></pre>
<p>将文件push到手机或模拟器中，最后，执行脚本</p>
<pre><code class="language-shell">adb shell monkey -f /sdcard/monkey.script –v 1
</code></pre>
<p>在手机上我们可以看到，Monkey脚本按照我们的设计的脚本执行了相应的动作。</p>
<blockquote>
<p>如果需要重复执行某个脚本，只要在Monkey启动命令中修改执行次数即可。例如:</p>
<pre><code class="language-shell">adb shell monkey -f /sdcard/monkey.script –v 10
</code></pre>
<p>此时Monkey会重复执行monkey.script脚本10次。</p>
</blockquote>
<p><strong>3.结合辅助命令，获取更多信息</strong></p>
<p>常规测试只要记录下Monkey日志，再分析Monkey日志检查是否有异常即可。但是，很多时候，测试除了想知道执行过程是否有异常，还需要能获取执行过程中的一些详细信息或性能数据，比如想知道Monkey执行过程中是否存在内存泄漏，需要获取内存信息。 这时候就需要借助一些辅助的命令来获取更多信息了。下面列举了几种Monkey测试中常用的辅助命令，使用方法也非常简单，只要在 执行Monkey的同时，另起一个命令行窗口输入对应命令执行即可</p>
<ul>
<li>获取logcat日志信息:</li>
</ul>
<pre><code>adb shell logcat -v time&gt;log.txt
</code></pre>
<ul>
<li>获取内存信息:</li>
</ul>
<pre><code>adb shell dumpsys meminfo &lt;进程名&gt;
</code></pre>
<ul>
<li>获取CPU消耗信息:</li>
</ul>
<pre><code>adb shell dumpsys cpuinfo &lt;进程名&gt;
</code></pre>
<ul>
<li>获取电量信息:</li>
</ul>
<pre><code>adb shell dumpsys battery
</code></pre>
<ul>
<li>获取GPU信息:</li>
</ul>
<pre><code>adb shell dumpsys gfxinfo &lt;进程名&gt;
</code></pre>
<ul>
<li>获取流量信息:</li>
</ul>
<pre><code>#某些厂商的设备上无法使用
adb shell cat/proc/uid_stat/&lt;被测应用的uid&gt;/tcp_rcv
</code></pre>
<blockquote>
<p>如何获取被测应用的UID</p>
<p>步骤1:查看被测应用的进程ID(PID)</p>
<pre><code>adb shell ps | grep &lt;被测应用包名&gt;
</code></pre>
<p>步骤2:查看被测应用的用户ID(UID)</p>
<pre><code>adb shell cat /proc/$pid/status
</code></pre>
</blockquote>
<h2 id="16-monkey日志分析">1.6 Monkey日志分析</h2>
<p>Monkey日志分析是Monkey测试中非常重要的一个环节，通过日志分析，可以获取当前测试对象在测试过程中是否会发生异常，以及发生的概率，同时还可以获取对应的错误信息，帮助定位和解决问题。介绍日志分析方法之前，先来看一下日志的保存方法。</p>
<h3 id="161-monkey日志的保存方法">1.6.1 Monkey日志的保存方法</h3>
<p>Monkey运行日志常见的保存方法有三种:</p>
<ul>
<li>保存在PC中，代码如下:</li>
</ul>
<pre><code>adb shell monkey [option] &lt;count&gt; &gt;/home/monkey.txt
</code></pre>
<ul>
<li>保存在手机中，代码如下</li>
</ul>
<pre><code>adb shell monkey [option] &lt;count&gt; &gt; /mnt/sdcard/monkey.txt
</code></pre>
<ul>
<li>标注流与错误流分开保存，代码如下</li>
</ul>
<pre><code>adb shell monkey [option] &lt;count&gt; 1&gt;/sdcard/monkey.txt 2&gt;/sdcard/error.txt
</code></pre>
<blockquote>
<p>日志：</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/06/02/SUMz4BNtmeKsJhR.png" alt="image.png" loading="lazy"></figure>
</blockquote>
<h3 id="162-monkey日志内容分析">1.6.2 Monkey日志内容分析</h3>
<p>Monkey运行时输出的日志一般包含四类信息，分别是测试命令信息、伪随机事件流信息、异常信息、Monkey执行结果信息</p>
<p>1)测试命令信息</p>
<p>Monkey启动后会输出当前所执行命令的各种参数信息，其中包括种子(Seed)信息、事件数量、可运行的应用列表以及各事件百分比等。这些信息都是通过Monkey命令参数所指定的，这部分日志信息的解析，如下所示。</p>
<pre><code>//测试命令信息

//随机种子值，执行事件数量
:Monkey: seed=1454215444564 count=10

//可运行的应用列表
:AllowPackage: &quot;com.sec.android.app.popupcalculator&quot;

//Category包含 LAUNCHER和MONKEY
:IncludeCategory: android.intent.category.LAUNCHER 
:IncludeCategory: android.intent.category.MONKEY 

//各事件的百分比
// Event percentages: 

// 0: 15.0% 事件0: --pct-touch

// 1: 10.0% 事件1: --pct-motion

// 2: 2.0% 事件2: --pct-pinchzoom

// 3: 15.0% 事件3: --pct-trackball

// 4: 0.0% 事件4: --pct-rotation

// 5: 0.0% 事件5: --pct-permission

// 5: 25.0% 事件6: --pct-nav

// 6: 15.0% 事件7: --pct-majornav

// 7: 2.0% 事件8: --pct-syskeys

// 8: 2.0% 事件9: --pct-appswitch

// 9: 1.0% 事件10: --pct-flip

// 10: 13.0% 事件11: --pct-anyevent
</code></pre>
<p><a href="https://android.googlesource.com/platform/development/+/refs/heads/master/cmds/monkey/src/com/android/commands/monkey/MonkeySourceRandom.java">源代码在这里</a></p>
<p>2)伪随机事件流信息</p>
<p>当Monkey开始执行测试后，会顺序输出执行的事件流信息，主要是前面提到的11大事件。这部分日志信息的解析，如下所示。</p>
<pre><code class="language-shell">//执行的事件流信息 

//启动App事件
:Switch: #Intent;action=android.intent.action.MAIN;category=android.intent.category.LAUNCHER;launchFlags=0x10200000;component=com.sec.android.app.popupcalculator/.Calculator;end
    // Allowing start of Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.sec.android.app.popupcalculator/.Calculator } in package com.sec.android.app.popupcalculator
:Sending Touch (ACTION_DOWN): 0:(576.0,470.0)
:Sending Touch (ACTION_UP): 0:(576.10016,449.71652)
:Sending Trackball (ACTION_MOVE): 0:(-5.0,-3.0)
:Sending Touch (ACTION_DOWN): 0:(996.0,2189.0)
:Sending Touch (ACTION_UP): 0:(987.718,2137.2007)
:Sending Touch (ACTION_DOWN): 0:(695.0,888.0)
:Sending Touch (ACTION_UP): 0:(697.2413,877.8434)
    // Injection Failed
:Sending Trackball (ACTION_MOVE): 0:(4.0,-4.0)
:Sending Trackball (ACTION_UP): 0:(0.0,0.0)
:Sending Touch (ACTION_DOWN): 0:(1061.0,1427.0)
:Sending Touch (ACTION_UP): 0:(1053.2065,1428.9296)
:Sending Trackball (ACTION_MOVE): 0:(3.0,-1.0)
:Sending Touch (ACTION_DOWN): 0:(83.0,739.0)
:Sending Touch (ACTION_UP): 0:(170.69313,728.6698)
:Sending Flip keyboardOpen=false
Got IOException performing flipjava.io.IOException: write failed: EINVAL (Invalid argument)
    // Injection Failed
:Sending Trackball (ACTION_MOVE): 0:(-3.0,0.0)
:Sending Touch (ACTION_DOWN): 0:(221.0,1004.0)
:Sending Touch (ACTION_UP): 0:(220.8598,1007.04846)
:Sending Trackball (ACTION_MOVE): 0:(-3.0,1.0)
</code></pre>
<p>3)异常信息</p>
<p>当Monkey执行过程中遇到错误时，会输出对应异常信息，如下所示。</p>
<pre><code>//发送 Crash的应用包名和pid
// CRASH: com.tencent.android.qqdownloader (pid 912) 

//Crash的简要信息
// Short Msg: java.lang.ClassNotFoundException 

//Crash的详细信息
// Long Msg: java.lang.ClassNotFoundException: Didn't find class &quot;com. qq.AppService.AstApp&quot; on path DexPathList[[zip file &quot;/data/app/com.tencent. android.qqdownloader-2.apk&quot;],nativeLibraryDirectories[/data/app-lib/com. tencent.android.qqdownloader-2, /vendor/lib, /system/lib]]
//机型和系统信息
// Build Label: Xiaomi/pisces/pisces:4.4.4/KTU84P/5.12.24:user/release-keys 
// Build Changelist: 5.12.24
// Build Time: 1450958964000

//Crash的详细日志
// java.lang.RuntimeException: Unable to instantiate application com. qq.AppService.AstApp: java.lan.ClassNotFoundException: Didn't find class &quot;com. qq.AppService.AstApp&quot; on path: DexPathList[[zip fil &quot;/data/app/com.tencent. android.qqdownloader-2.apk&quot;],nativeLibraryDirectories=[/data/app-lib/com. tecent.android.qqdownloader-2, /vendor/lib, /system/lib]]
// at android.app.LoadedApk.makeApplication(LoadedApk.java:509)
// at android.app.ActivityThread.access$1500(ActivityThread.java:138)
// at dalvik.system.NativeStart.main(Native Method)
// ... 11 more //
</code></pre>
<p>4)Monkey执行结果信息</p>
<p>当Monkey执行完所有事件后，会输出执行结果信息，其中包括执行的事件数量、旋转的角度、丢失的事件数量、网络状态以及Monkey最终的执行结果，如下所示。</p>
<pre><code>//执行的事件数量
Events injected: 100

//旋转的角度为0
:Sending rotation degree=0, persist=false

//丢失的事件数量
:Dropped: keys=0 pointers=1 trackballs=0 flips=1 rotations=0

//网络状态
## Network stats: elapsed time=262ms (0ms mobile, 0ms wifi, 262ms not connected)
// Monkey finished
</code></pre>
<p>如果Monkey执行过程中出现了异常导致执行失败，会输出对应的执行失败的原因，第几个事件执行失败以及所使用的随机种子数，如下所示。</p>
<pre><code>//显示Monkey执行失败
** Monkey aborted due to error.

//执行的事件数量
Events injected: 8

//旋转的角度为0
:Sending rotation degree=0, persist=false /

/丢失的事件数量
:Dropped: keys=0 pointers=0 trackballs=0 flips=0 rotations=0 

//网络状态
## Network stats: elapsed time=405ms (0ms mobile, 0ms wifi, 405ms not connected) 

//提示在执行到第8个事件时出现 Crash，以及所使用的随机种子的值
** System appears to have crashed at event 8 of 100 using seed 1454216848235

</code></pre>
<h3 id="163-monkey日志异常信息查找">1.6.3 Monkey日志异常信息查找</h3>
<p>Monkey执行过程中常见的错误类型主要有两类:应用程序无响应(ANR)和崩溃(Crash)。</p>
<p>ANR是指当Android系统监测到应用程序在5秒内没有响应输入的事件或广播在10秒内没有执行完毕时抛出无响应提示。</p>
<p>rash是指当应用程序出现错误时导致程序异常停止或退出的情况.</p>
<p>要统计Monkey日志中错误出现的次数也非常简单，只要搜索关键字“ANR”和“CRASH”出现的次数即可。</p>
<p>通过详细日志信息，测试可以定位到引起Crash的原因，以及出现Crash的代码行信息。这里给出常见的一些Crash错误信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Crash关键字</th>
<th style="text-align:center">Crash原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">java.lang.NullPointerException</td>
<td style="text-align:center">空指针异常</td>
</tr>
<tr>
<td style="text-align:center">java.lang.ArrayIndexOutOfBoundsException</td>
<td style="text-align:center">数组溢出</td>
</tr>
<tr>
<td style="text-align:center">java.lang.ClassNotFoundException</td>
<td style="text-align:center">类不存在</td>
</tr>
<tr>
<td style="text-align:center">java.lang.ArithmeticException</td>
<td style="text-align:center">数学运算异常</td>
</tr>
<tr>
<td style="text-align:center">java.lang.IlleagalArgumentException</td>
<td style="text-align:center">方法参数异常</td>
</tr>
<tr>
<td style="text-align:center">java.io.FileNotFoundException</td>
<td style="text-align:center">文件未找到</td>
</tr>
<tr>
<td style="text-align:center">java.lang.NumberFormatException</td>
<td style="text-align:center">数值转化异常</td>
</tr>
<tr>
<td style="text-align:center">java.lang.StackOverflowException</td>
<td style="text-align:center">堆栈异常错误</td>
</tr>
<tr>
<td style="text-align:center">java.lang.OutOfMemoryException</td>
<td style="text-align:center">内存溢出错误</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[adb的使用]]></title>
        <id>https://theotop97.github.io/post/test-android/</id>
        <link href="https://theotop97.github.io/post/test-android/">
        </link>
        <updated>2021-05-15T15:37:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>adb ( Android Debug Bridge)是一个通用命令行工具，其允许您与模拟器实例或连接的 Android 设备进行通信。它可为各种设备操作提供便利，如安装和调试应用。</p>
<h1 id="配置">配置</h1>
<p>需要配置adb环境，根据个人机器和喜好配置即可。</p>
<h1 id="常用命令">常用命令</h1>
<p><strong>启停服务</strong></p>
<ul>
<li><code>adb kill-server</code></li>
<li><code>adb start-server</code></li>
</ul>
<p><strong>查看已连接的设备</strong></p>
<ul>
<li><code>adb devices</code></li>
</ul>
<p><strong>获取设备的状态</strong></p>
<ul>
<li>
<p><code>adb get-state</code></p>
<blockquote>
<p>设备的状态有 3 种：</p>
<p>​		<code>device</code>：设备正常连接</p>
<p>​		<code>offline</code>：连接出现异常，设备无响应</p>
<p>​		<code>unknown</code>：没有连接设备</p>
</blockquote>
</li>
</ul>
<p><strong>查看设备安装的应用</strong></p>
<ul>
<li>
<p><code>adb shell pm list package xxx(应用名)</code></p>
<ul>
<li>-s: 列出系统应用</li>
<li>-3: 列出第三方应用</li>
<li>-f: 列出应用包名及对应的apk名及存放位置</li>
<li>-i: 列出应用包名及其安装来源，结果显示例子</li>
</ul>
<blockquote>
<p>命令最后增加 FILTER：过滤关键字，可以很方便地查找自己想要的应用</p>
<pre><code class="language-shell">adb shell pm list package -f -3 -i qq  

package:/mnt/asec/com.tencent.mobileqq-bkqW0nLSfyRsIjb5/base.apk=com.tencent.mobileqq installer=com.samsung.android.packageinstaller
</code></pre>
</blockquote>
</li>
<li>
<p><code>pm path</code> 列出对应包名的 .apk 位置</p>
<pre><code class="language-shell">adb shell pm path com.tencent.mobileqq
package:/mnt/asec/com.tencent.mobileqq-bkqW0nLSfyRsIjb5/base.apk
</code></pre>
</li>
</ul>
<p><strong>给设备安装应用</strong></p>
<ul>
<li>
<p><code>adb install</code></p>
<blockquote>
<p><code>-r:</code> 覆盖原安装文件</p>
<p><code>-s:</code>指定设备</p>
</blockquote>
<ul>
<li>
<p><strong>默认安装</strong></p>
<p><code>adb install /xxxxx/xxxxx/xxx.apk</code></p>
</li>
</ul>
</li>
</ul>
<p><strong>卸载设备应用</strong></p>
<ul>
<li>
<p><code>adb uninstall packagename</code></p>
<blockquote>
<p>adb uninstall com.tencent.mobileqq</p>
</blockquote>
</li>
</ul>
<p><strong>文件从PC push到设备</strong></p>
<ul>
<li><code>adb push /Users/kyb.txt /sdcard</code></li>
</ul>
<p><strong>文件从设备pull到PC</strong></p>
<ul>
<li><code>adb pull /sdcard/server.log /Users</code></li>
</ul>
<blockquote>
<p>图片不要用<code>.jpg</code></p>
</blockquote>
<p><strong>屏幕截图</strong></p>
<ul>
<li><code>adb shell screencap 截图存放截图位置</code></li>
</ul>
<blockquote>
<p><code>adb shell screencap /sdcard/screen.png</code></p>
</blockquote>
<p><strong>dumpsys工具</strong></p>
<ul>
<li>
<p>activity栈信息：<code>adb shell dumpsys activity</code></p>
<blockquote>
<p>查看当前活动的Activity</p>
<pre><code class="language-shell">adb shell dumpsys window windows | grep &quot;mCurrentFocus&quot;
mCurrentFocus=Window{7ba82b1 u0 com.tencent.mobileqq/com.tencent.mobileqq.activity.SplashActivity}
</code></pre>
<p>com.tencent.mobileqq: 包名</p>
<p>com.tencent.mobileqq.activity.SplashActivity： Activity名</p>
</blockquote>
</li>
<li>
<p>内存信息：<code>adb shell dumpsys meminfo</code></p>
</li>
<li>
<p>电池信息：<code>adb shell dumpsys battery</code></p>
</li>
</ul>
]]></content>
    </entry>
</feed>